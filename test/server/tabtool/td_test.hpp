//THIS FILE IS GENERATED BY tabtool, DO NOT EDIT IT!
//GENERATE TIME [2018/1/19 15:42:21]
#pragma once
# include "readtablefield.h"
# include "tablestruct.h"

namespace game_data {

struct td_head_item;
struct td_test_item {
  int32_t role_id;
  int32_t cost_type;
  int32_t attack_type;
  int64_t head_id;
  tbsIdCount test1;
  vector<tbsKeyValue> test2;
  tbsTest test3;
  std::vector<const td_head_item*> __relate__td_head_items;
};

class td_test : public IConfigTable<td_test_item>{
public:
virtual bool Load() {
	ReadTableFile reader;
	reader.Initialize();

	if (!reader.Init(GetTableFile().c_str()))
		return false;

	try {
		DataReader dr;
		int iRows = reader.GetRowCount();
		int iCols = reader.GetColCount();
		for (int i = 1; i < iRows; ++i) {
			td_test_item item;
			item.role_id = dr.GetValue<int32_t>(reader.GetValue(i, "role_id"));
			item.cost_type = dr.GetValue<int32_t>(reader.GetValue(i, "cost_type"));
			item.attack_type = dr.GetValue<int32_t>(reader.GetValue(i, "attack_type"));
			item.head_id = dr.GetValue<int64_t>(reader.GetValue(i, "head_id"));
			item.test1 = dr.GetObject<tbsIdCount>(reader.GetValue(i, "test1"));
			item.test2 = dr.GetObjectList<tbsKeyValue>(reader.GetValue(i, "test2"));
			item.test3 = dr.GetObject<tbsTest>(reader.GetValue(i, "test3"));
			m_Items[item.role_id] = item;
		}
	} catch(std::exception& e) {
		std::cerr << e.what() << std::endl;
		return false;
	}
	return true;
}

string GetTableFile() {
	string f = WORK_DIR;
	f = f + "test.txt";
	return f;
}

};

}
